SQL Coding Standards
Caution
This is an old document and user are encouraged to refer to Microsoft SQL best practice
Introduction
SQL Server coding guidelines are developed keeping in mind the performance, quality, and maintainability of the SQL Server Databases. Following the current standards will help minimize/eliminate database-related bottlenecks, thus improving the performance of the application. SQL DBA team does the code review keeping the following guidelines in mind for all the database releases
SQL Coding Standards
1.	In the SELECT clause, make sure that each data element is requested explicitly. Using "SELECT * FROM ..." forces SQL Server to do a system table lookup to determine all the columns in the table which adversely impacts performance.
2.	Ensure that data types match (no implicit conversions) across tables that could potentially be joined. If this is not done, even with proper indexing, a table scan will occur on the join.
3.	All created objects must be needed and used.
4.	All created objects must be destroyed (and as soon as no longer needed)
5.	Limit dynamic SQL (i.e. using sp_executesql or exec to execute a dynamically built SQL string) unless absolutely necessary. Very difficult to debug and has an adverse impact on performance.
6.	Limit the use of cursors because they are very resource-intensive.
7.	Write comments in your triggers, cursors, and SQL batches.
8.	Try to avoid server-side cursors as much as possible. Always stick to 'set-based approach' instead of a 'procedural approach' for accessing/manipulating data. Cursors can be easily avoided by SELECT statements in many cases. If a cursor is unavoidable, use a simple WHILE loop instead, to loop through the table. I personally tested and concluded that a WHILE loop is faster than a cursor most of the time. But for a WHILE loop to replace a cursor you need a column (primary key or unique key) to identify each row uniquely and I personally believe every table must have a primary or unique key.
9.	Avoid the creation of temporary tables while processing data, as much as possible, as creating a temporary table means more disks IO. Consider advanced SQL or views or table variables of SQL Server or derived tables, instead of temporary tables. Keep in mind that, in some cases, using a temporary table performs better than a highly complicated query.
10.	Try to avoid wildcard characters at the beginning of a word while searching using the LIKE keyword, as that result in an index scan, which is defeating the purpose of having an index. The following statement results in an index scan, while the second statement results in an index seek: 
1.	SELECT LocationID FROM Locations WHERE Specialities LIKE '%pples'
2.	SELECT LocationID FROM Locations WHERE Specialities LIKE 'A%s'
11.	Avoid dynamic SQL statements as much as possible. Dynamic SQL tends to be slower than static SQL, as SQL Server must generate an execution plan every time at runtime. IF and CASE statements come in handy to avoid dynamic SQL.
 Stored Procedures
1.	Comment All Stored Procedures
2.	All Database access via stored procedures
3.	Naming conventions:
4.	Stored Procedure names should never be prefixed with sp_ (or SP_)
5.	A good practice is to use a descriptive name with _sp (or _SP) as a suffix (e.g. GetScoreCardSummaryData_SP)
6.	Make sure execute permissions are applied to only the application's credentials
7.	No "Select * From table name"
8.	Make sure that each data element is requested explicitly.
9.	No Implicit Conversions
10.	Ensure that data types match across tables that could potentially be joined. If this is not done, even with proper indexing, a table scan will occur on the join.
11.	Limit dynamic SQL unless absolutely necessary(i.e. using sp_executesql or exec to execute a dynamically built SQL string)
12.	Limit the use of cursors they are very resource-intensive.
13.	Parameters must be used and passed correctly in order of proper execution of Stored Procedure.
14.	If your stored procedure always returns a single row resultset, consider returning the resultset using OUTPUT parameters instead of a SELECT statement, as ADO handles output parameters faster than resultsets returned by SELECT statements
Transactions

Anytime an application performs multiple updates, deletes or inserts (or any combination thereof) that are dependent upon one another, a transaction should be used to ensure all changes are rolled back in the event of an error.
All the transactions should have Begin Transaction and should end with Commit Transaction for correct data value or with Rollback Transaction if error found due to disconnection, incorrect values, etc.
BEGIN TRANSACTION
Represents a point at which the data referenced by a connection is logically and physically consistent. If errors are encountered, all data modifications made after the BEGIN TRANSACTION can be rolled back to return the data to this known state of consistency. Each transaction lasts until either it completes without errors and COMMIT TRANSACTION is issued to make the modifications a permanent part of the database, or errors are encountered and all modifications are erased with a ROLLBACK TRANSACTION statement.
BEGIN {TRAN | TRANSACTION} 
    [{transaction{_}name | @tran_name_variable}
      [WITH MARK ['description']]
    ]
[ ; ]
COMMIT TRANSACTION
It is the responsibility of the Transact-SQL programmer to issue COMMIT TRANSACTION only at a point when all data referenced by the transaction is logically correct.
COMMIT {TRAN | TRANSACTION} [transaction_name | @tran_name_variable]]
[ ; ]
ROLLBACK TRANSACTION 
Rolls back an explicit or implicit transaction to the beginning of the transaction, or to a savepoint inside the transaction. ROLLBACK TRANSACTION without a savepoint_name or transaction_name rolls back to the beginning of the transaction.
ROLLBACK {TRAN | TRANSACTION} 
     [transaction_name | @tran_name_variable
     | savepoint_name | @savepoint_variable] 
[ ; ]
Indexing
1.	Create the clustered index on every table. However, choose the column(s) for the clustered index judiciously. Try to create the clustered index on the column which is used most frequently for retrieving data.
2.	Proper indexing is very important. Index Seeks is recommended for faster query performance.
3.	Create the clustered index on the column that will never be updated or will be updated infrequently. Every time the clustered index key is updated, SQL Server must maintain not just the clustered index but also the non-clustered indexes since non-clustered indexes contain a pointer to the clustered index. This is yet another reason why you shouldn't create the clustered index on multiple columns.
4.	The Index Fill Factor should always be kept at Default Value unless there is a specific reason to change it, the DBA team should be provided with justification.
Performance Tuning With Indexes
Indexes are applied to a table column or combination of columns to improve query performance. The results can often be dramatic, even reducing a query that might take several minutes to execute without indexes to one that executes in less than a second. Proper indexing can transform a database application from one that returns results so slowly that no one wants to use it into one that displays data almost instantly. As you can see, proper indexing is very important. You can add indexes to a table using either SQL Server Enterprise Manager or Query Analyzer. See Books Online (use keyword indexes) for more info. To test your indexes (or determine where indexing needed) use Query Analyzer. Under the Query, menu select Show Execution Plan. Then run your stored procedure with parameters manually keyed in as needed. Once executed click on the Execution Plan tab. Rule of thumb: Seeks = GOOD Scans = BAD. See Books Online (use keyword execution plan) for more info. For professional index consulting contact the SQL DBA TEAM.
Also, note that each table can have only one clustered index. A clustered index identifies a column(s) by which the table is physically sorted. Choosing this index wisely is very important. See Books Online (use keyword clustered indexes) for more info.
Error Trapping
Error Trapping must be performed when error conditions possible. Using error handling in stored procedures is imperative to ensure the stored procedure completed all tasks successfully. Every time you perform an operation, you must check for an error. If you do not, you will have no idea if the operation completed successfully or not. See Books Online (use keyword error object) for more info.
SQL Server Integration Services (SSIS)
1.	Email notification should be sent out to the primary app POC or to the app team email. The failure email should include error information in the message body.
2.	Variables defined in the package should be commented in the comments section
3.	The comment section should also include the SSIS build date, App team who own the SSIS and name of the developer.
Error Handling
Using error handling in stored procedures is imperative to ensuring the stored procedure completed all tasks successfully. Every time you perform an operation, you must check for an error. If you do not, you will have no idea if the operation completed successfully or not. See Books Online (use keyword error object) for more info.

SQL Code Review Workflow
Introduction
While we follow industry standard processes, there are always components of the process that are unique to each team. This article is designed to help introduce new team members to our process, as well as to ensure that everyone is on the same page. If you have questions, comments, or concerns about anything in this article, please let us know.
When It All Goes Right (Workflow Steps)
Ideally, our process should look something like this:
Application Code Review 
•	Application team identifies a change that needs to be made to the system
•	The affected Scrum Team is identified, and a work item is opened on their backlog
•	Analysis of the work item is completed by the Scrum Team
•	An Architectural Review is completed (if needed)
•	The item is pulled into the Sprint and assigned to a Developer
•	The developer moves the item into “[TODO: Work Item Status?]“ status and begins work
o	The developer creates a branch to work on the issue
o	The developer consults SMEs for guidance, as needed (SME Review)
o	The developer asks other team members for input, as needed (Peer Review)
o	The developer commits changes as they go
o	The developer initiates a Pull Request, and assigns it to an approved Code Reviewer
SQL Code Review
•	Application DBA is the primary reviewer to review the code.
•	SQL DBA is the secondary reviewer, on the request of Application DBA.
•	If Application DBA need additional code review, he can share the Pull request on the WebEx team application code review channel.
•	The Code Reviewer evaluates and approves the Pull Request (Code Review) and provides comments.
